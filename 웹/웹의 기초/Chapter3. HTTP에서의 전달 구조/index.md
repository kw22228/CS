### HTTP에서의 전달 구조

#### 1.HTTP 메세지

- HTTP란?

  - HTML등의 텍스트 파일이나 이미지 등의 콘텐츠를 전달하기 위해 사용하는 프로토콜이다.
  - 초창기에는 텍스트 정보만 송신하는 단순한 프로토콜이엿다.

- 요청과 응답
  - 클라이언트인 웹브라우저가 요청을 보내고, 서버인 웹서버가 그 요청에 대한 응답을 반환한다.
  - 기본적으로 1요청 1응답을 한다.

#### 2.HTTP 요청과 응답

- HTTP 요청

  - 요청 행, 메세지 헤더, 메세지 바디 이렇게 세 부분으로 나눌 수 있다.
  - 기능
    - 요청 행: 웹서버에 대해 어떤 처리를 하기 원하는지에 대한 요청 내용을 기술한다. (정보를 얻고싶다. , 정보를 수신하고 싶다.)
    - 메세지 헤더: 웹브라우저의 종류나 버전, 대응하는 데이터 형식 등 부가적인 정보를 기술 한다.
    - 메세지 바디: 웹페이지 안의 폼 등에 입력한 텍스트 데이터 등을 웹서버에 보내는 목적으로 사용.

- HTTP 응답
  - 상태 행, 메세지 헤더, 메세지 바디 이렇게 세 부분으로 나눌 수 있다.
  - 기능
    - 상태 행: 클라이언트로부터 받은 HTTP요청에 대해 웹서버 안에서의 처리 결과를 전달한다.
    - 메세지 헤더: 웹서버의 종류나 송신하는 데이터의 형식 등 부가적인 정보를 기술한다.
    - 메세지 바디: 웹브라우저로부터 요청된 HTML등의 데이터가 저장된다.

#### 3.HTTP 메서드

- 메서드 종류

  - GET: HTML파일 등 콘텐츠를 얻고 싶을때
  - POST: 데이터를 웹서버에 전달할 때
  - PUT: 웹서버가 보관하고 있는 콘텐츠를 수정하거나 삭제할 때
  - DELETE: 웹사이트 조작의 위험성이 있어 웹서버 측에서 대부분 사용할 수 없도록 한다.

- GET vs POST
  - 두 메서드 다 데이터를 송신할 수 있지만, 그 방법이 다르다.
  - GET은 URL뒤에 QUERY STRING을 붙여 데이터를 보낸다. 요청 행의 url에 붙인다. (보낸 데이터가 노출 될 수 있고, URL에 글자 수 제한이 있는 브라우저(edge)에서는 긴 데이터는 보낼 수 없다.)
  - POST는 HTTP요청 안의 메세지 바디 안에 데이터를 포함시켜 보낸다. (보낸 데이터가 HTTP 바디에 숨겨지고, 큰 데이터를 보낼 수 있다.)

#### 4.상태 코드

- HTTP 요청에 대한 웹서버 안에서의 처리 결과가 HTTP 응답에 포함된다. 이것이 상태 코드이다.
- 100번 ~ 500번대 까지 다섯 종류로 구분된다.
- 상태코드 분류
  - 100번대: HTTP 요청을 처리하고 있음을 알린다. 웹서버가 데이터를 받을 수 있는지 확인하기 위한 일시적인 응답으로 사용.
  - 200번대: HTTP 요청을 정상적으로 처리하였음을 알린다. 웹브라우저 상에서 웹사이트가 정상적으로 표시된경우는 대부분 이 상태 코드가 반환된다.
  - 300번대: HTTP 요청에 대해 전송 처리 등의 웹브라우저 측에서 추가 처리가 필요함을 알린다. 웹사이트의 URL이 변경된 경우 사용
  - 400번대: 클라이언트(브라우저)의 에러임을 알린다. 요청된 HTML 파일등이 웹서버에 존재하지 않을때 반환한다.
  - 500번대: 웹서버에서 에러가 났을경우 발생한다. 웹서버가 무언가의 에러에 의해 요청에 응답할 수 없거나 높은 부하 상태로 인해 일시적으로 웹 콘텐츠를 전송할 수 없는 경우 반환.

#### 6.TCP를 통한 데이터 통신

- TCP에서는 먼저 클라이언트와 서버가 서로 통신할 수 있는 상황인지 확인하고, 커넥션이라 불리는 통신 경로를 확립한다.
  그 후에 데이터를 전달한다.
- 커넥션 확립 과정 (3핸드셰이킹)
  - 클라이언트로부터의 연결 요청(SYN)
    - 클라이언트로부터 서버로 연결을 요청하기 위해 SYN패킷이라 불리는 데이터를 보낸다.
      SYN패킷을 받은 서버는 그에 대해 응답한다.
  - 클라이언트에게 확인 응답 및 서버로부터의 연결 요청(SYN + ACK)
    - TCP는 신뢰성이 있는 통신을 하기 위해 데이터를 송신하고 반드시 상대로부터 확인응답을 받아야 데이터 송신이 완료된것으로 간주한다.
      이 확인 응답이 ACK패킷 이다. 클라이언트로부터의 연결 요청에 대해 서버가 ACK 패킷을 송신함으로써, 연결 가능함을 전달한다.
  - 서버에 확인 응답(ACK)
    - 서버로부터의 연결 요청에 대해 클라이언트는 ACK패킷을 송신한다.
      이렇게 서로 SYN패킷을 보내고 ACK패킷으로 응답함으로써 양방향에서 통신이 가능한 것을 확인하고, 커넥션 확립을 완료한다.

#### 7.HTTP/1.1의 통신

- HTTP 킵 얼라이브

  - 원래 HTTP요청을 송신할 때 TCP에 대해 커넥션을 확립하고 웹서버가 HTTP 응답으로서 데이터를 전달하는 단계에서 커넥션을 닫는 방식을 사용했다.
    그렇기 때문에 웹페이지 안에 이미지가 있는 경우, 커넥션 확립후 페이지를 받은후 커넥션 끊고 다시 커넥션 연결후 이미지 받고 커넥션 닫고 이런 방법을 사용했다.
  - 그래서 HTTP/1.1에서부터는 HTTP 킵 얼라이브 기능이 생겼고 이것으로이해 응답을 받은후에도 커넥션을 유지하는 방법을 사용되었다.

- HTTP 파이프라인
  - HTTP를 순차적으로 여러 HTTP요청을 송신하게 하기 위한 방법.
  - HTTP/2.0 부터는 멀티플렉싱 기술로 여러개의 HTTP요청을 할 수 있음.

#### 8.HTTP/2 통신

- 웹사이트가 복잡해짐에 따라 데이터 전달을 고속화할 목적으로 등장하였다.
- 스트림을 통한 다중화
  - 기존에는 요청과 응답을 하나씩만 송수신 할 수 있어 파이프라인을 제공했지만, 이 파이프라인도 HTTP요청을 순서대로 반환해야 한다는 제약이있었다.
    그렇기때문에 병목현상이 일어날 수 있었다.
  - TCP 컨넥션상에 스트림 이라 불리는 가상적인 통신 경로를 여럿 생성하고, 각각의 스트림안에서 HTTP요청과 응답을 전달할 수 있게 되었다.
    따라서, 더 빠르고 효율적인 데이터 전달이 가능해짐.

#### 9.HTTP/2의 개선점

- 바이너리 형식 사용

  - 1.1 이전에는 텍스트 형식의 포맷을 전달했지만, 2버전에서는 효유적인 데이터 전달을 위해 바이너리 형식의 포맷을 사용한다.
  - 1.1 이전에는 바이너리 형식 데이터를 전달하기 전에 먼저 텍스트 형식으로 변환해야 했지만, 2에서는 바이너리 형식을 그대로 전달한다.

- 헤더 압축

  - HTTP헤더 정보 즉, 요청에서 사용하는 웹브라우저 종류, 웹서버의 버전 정보 등.. 요청이나 응답을 할때 헤더 정보의 다른 부분만 전송(중복x)하는 HPACK이라 불리는 압축 방식을 사용하여 전송량을 줄인다.

- 서버 푸시
  - HTTP/2 에서는 웹브라우저의 요청 내용을 기반으로 웹서버 측에서 필요한 파일을 판단하고, 사전에 웹브라우저에 송신할 수 있다.
  - HTML파일에 이미지가 있다면 HTML과 필요한 이미지 데이터까지 전송한다.

#### 10.HTTPS의 구조

- HTTPS란 HTTP over SSL/TLS의 약어로 HTTP 통신에서 암호화 방식인 SSL이나 TLS를 사용함으로써 웹사이트를 안전하게 사용할 수 있게한다.
- 안정성 확보 구조
  - 도청 방지(암호화 통신)
    - 웹사이트를 열람할때 제삼자가 통신 내용을 갈취하는것은 비교적 간단하다.
      따라서, 내용을 갈취해도 내용을 해독할 수 없게 하기 위해 데이터를 암호화해 전송함으로써 도청을 방지한다.
  - 변조 방지
    - 네트워킹에서 송금처 정보가 바뀌어 버리는 것과 같은 데이터 변조에 대한 대책으로 '메세지 다이제스트'를 사용한다.
    - 메세지 다이제스트란 어떤 데이터로부터 유일한 짧은 데이터(해시값)를 추출하는 계산을 말한다. 데이터 송 수신시 해시값을 비교해 변조를 검사 할 수 있다.
  - 위장 방지(웹사이트 운용 소스 확인)
    - 웹서버에 SSL인증서를 배치하고 연결 시 검증함으로써, 웹사이트를 운영하는 회사의 신원을 확인할 수 있다.
    - 또한, SSL인증서는 발행을 받은 인증 기관에 따라 운영 소으의 인증 작업을 통과해야 하기 때문에, 신뢰할 수 없는 발생 소스의 SSL인증서를 사용한 경우에는 웹브라우저상에서 경고 화면이 표시된다.

#### 11.HTTPS 통신

- SSL/TLS 핸드셰이크

  1. 암호화 방식 결정

     - 암호화 방식은 여러가지가 존재하기 때문에 브라우저와 서버 양쪽이 사용할 수 있는 암호화 방식을 결정할 필요가 있다.
       이 단계에서는 암호화 방식을 결정하는 것 외에 HTTPS에서 사용되는 SSL 또는 TLS버전과 위변조 방지에서 사용되는 메세지 다이제스트 방식을 결정한다.

  2. 통신 상대 인증

     - 이 단계에서는 웹브라우저가 통신하고 있는 웹서버가 올바른 상대인지를 SSL인증서를 사용해 확인한다.
     - 올바른 웹서버임을 확인할 수 없는 경우는 웹브라우저상에 경고가 표시된다.

  3. 키 교환

     - 이 단계에서는 데이터 전송에 사용하는 키를 교환한다. 키는 데이터를 전송할 때의 암호화 및 암호화된 데이터를 복호화할 때 사용된다.

  4. 암호화 방식 확인

     - 마지막 단계에서는 실제로 사용하는 암호화 방식의 최종 확인작업을 수행한다.
     - 이단계가 완료되면 브라우저와 서버 사이에서 암호화 통신이 시작된다.

#### 스테이트풀과 스테이트리스

- HTTP는 단순한 프로토콜이며, 스테이트리스 이다.
- 스테이트리스는 '상태를 유지하지 않는다'는 의미이고 요청/응답을 1회 왕복하면 전달처리가 완결된 것으로 간주하고 여러 처리를 연결짓는 구조가 된다.
- 스테이트풀은 '상태를 유지한다'는 의미이고 요청/응답을 왕복해도 이전 HTTP의 상태를 유지한다.
  때문에, 1대1 통신이라면 상태를 유지하는데 부담이없지만 1대의 서버로 여러 클라이언트의 상태를 유지한다면 부담이 된다.

#### 쿠키

- HTTP는 스테이트리스 프로토콜이므로 브라우저와 서버의 통신에 대한 상태를 유지하기 어렵다.
  때문에, 장바구니와 같은 상태를 유지하고 관리해야 할 때는 쿠키라는 데이터를 사용한다.

- 쿠키 전달
  - 웹서버에 연결을 한 브라우저에 대해 콘텐츠 등과 함께 브라우저에 저장할 정보를 쿠키로서 보낸다. (웹서버에서 set-cookie를통해 브라우저에 전달 후 브라우저에 저장.)
- 세션 헤더 사용
  - 웹서버는 HTTP 응답에 Set-Cookie 헤더를 포함해 쿠키를 송신하고, 브라우저는 HTTP 요청에 Cookie 헤더를 포함해 송신한다.
- 세션 쿠키
  - 유효 기간이 설정되어있지 않은 쿠키는 웹브라우저가 닫힐 때 동시에 삭제된다 이것을 세션 쿠키 라고한다. (세션 스토리지와 비슷)
  - 유효 기간이 설정된 쿠키는 브라우저를 닫아도 삭제되지 않고 유효기간이 될 때까지 브라우저상에 남는다.
