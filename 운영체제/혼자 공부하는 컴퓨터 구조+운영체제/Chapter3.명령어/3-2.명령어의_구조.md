### 3-2. 명령어의 구조

- 명령어는 연산코드 + 오퍼랜드 의 구조로 구성된다.

- 연산 코드와 오퍼랜드

  | 연산코드 | 오퍼랜드               |
  | -------- | ---------------------- |
  | push     | rbp, rsp               |
  | mov      | edx, DWORD PTR [rbp-4] |

  - 연산코드(연산자) : 명령어가 수행할 연산

    - 종류

      1. 데이터 전송

      - MOVE : 데이터를 옮겨라.
      - STORE : 메모리에 저장해라.
      - LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
      - PUSH : 스택에 데이터를 저장해라
      - POP : 스택의 최상단 데이터를 가져와라

      2. 산술/논리 연산

      - ADD / SUBTRACT / MULTIPLY / DIVIDE : 덧셈 / 뺄셈 / 곱셈 / 나눗셈 을 수행하라.
      - INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 1을 빼라
      - AND / OR / NOT : AND / OR / NOT 연산을 수행하라.
      - COMPARE : 두 개의 숫자 또는 TRUE / FALSE값을 비교하라.

      3. 제어 흐름 변경

      - JUMP : 특정 주소로 실행 순서를 옮겨라
      - CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라.
      - HALT : 프로그램의 실행을 멈춰라.
      - CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라.
      - RETURN: CALL을 호출할 때 저장했던 주소로 돌아가라.

      4. 입출력 제어

      - READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라.
      - WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라.
      - START IO: 입출력 장치를 시작하라.
      - TEST IO: 입출력 장치의 상태를 확인하라.

  - 오퍼랜드(피연산자) : 연산에 사용할 데이터가 저장된 위치. (숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소)

    - 주소 필드로 부르기도 한다. 숫자나 문자와 같이 연산에 사용할 데이터를 직접 명시하기 보다는
      연산에 사용할 데이터가 저장된 위치 즉, 메모리 주소나 레지스터 이름이 담긴다.
    - 오퍼랜드는 명령어 안에 아예 없을 수도 있고, 1개만있을수도 그 이상 있을수도 있다.

- 주소 지정 방식

  - 오퍼랜드 필드에 데이터가 저장된 위치를 명시 할때 연산에 사용할 데이터 위치를 찾는 방법

  - 주소 지정 방식 종류

    1. 즉시 주소 지정 방식

    - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식.
    - 장점 : 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 속도가 빠르다.
    - 단점 : 표현할 수 있는 데이터의 크기가 작아진다.

    2. 직접 주소 지정 방식

    - 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식.
    - 즉시 주소 지정 방식보다는 데이터의 크기가 커졋지만, 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수 만큼 줄어들었다.

    3. 간접 주소 지정 방식

    - 유효 주소의 주소를 오퍼랜드 필드에 명시한다. (오퍼랜드에 유효주소의 주소 -> 메모리의 유효주소 -> 유효주소의 데이터)
    - 두번의 메모리 접근이 필요하기 때문에 일반적으로 느리다.

    4. 레지스터 주소 지정 방식

    - 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시한다.
    - 일반적으로 CPU외부에 있는 메모리보다는 내부에있는 레지스터접근이 더 빠르다. 하지만 직접 주소 지정 방식과 비슷하게 레지스터의 유효주소를 표현할 수 있는 범위가 제한되어있다.

    5. 레지스터 간접 주소 지정 방식

    - 오퍼랜드에 유효주소의 주소를 가지고있는 레지스터 주소를 저장한다. (오퍼랜드에 유효주소의 레지스터 주소 -> 메모리의 유효주소 -> 유효주소의 데이터)
    - CPU 내부에있는 레지스터를 접근하고 메모리에 접근하는 것이기 때문에 간접 주소 지정방식보다 빠르다.

    6. 스택 주소 지정 방식

    - 스택과 스택 포인터를 이용한 주소 지정 방식이다.

    7. 변위 주소 지정 방식

    - 오퍼랜드 필드값과 특정 레지스터의 값을 더하여 유효 주소를 얻어대는 주소 지정 방식이다.
    - | 연산코드 | 레지스터 | 오퍼랜드 | 의 구조로 되어있음.
    - 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 "상대 주소 지정방식", "레지스터 주소 지정 방식" 등으로 나뉜다.

    8. 상대 주소 지정 방식

    - 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
    - ex) 오퍼랜드가 -3이엿을 경우 CPU는 읽어 들이기로 한 명령어로부터 세번째 이전 번지로 접근한다. (1000번지 였으면 997번지로 들어감)
    - if문과 유사하게 모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 때 사용된다.

    9. 베이스 레지스터 주소 지정 방식

    - 오퍼랜드와 베이스 레지스터의 값을 더하여 유효주소를 얻는 방식.
      베이스 레지스터는 '기준 주소', 오퍼랜드는 '기준 주소로부터 떨어진 거리'를 나타낸다.
    - ex) 베이스 레지스터에 200이라는 값이 있고, 오퍼랜드가 40이라면 -> 기준 주소 200번지로부터 40만큼 떨어진 240번지로 접근하라.

- 유효주소란?
  - 연산코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치
