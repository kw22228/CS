### 페이징을 통한 가상메모리 관리

- 가상메모리란?
  - 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다.
  - 이를 가능케하는 가상 메모리 관리 기법은 크게 "페이징" 과 "세그멘테이션" 기법이 있다.

#### 페이징이란

- 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당하게 되면 외부 단편화가 일어난다.
  하지만, 각각의 메모리를 일정한 단위로 잘라서 메모리에 불연속적으로도 할당 할 수 있다면 외부 단편화는 일어나지 않는다.
  이렇게 각각의 메모리를 일정한 단위로 자르는 방식을 "페이징" 이라고 한다.
- 페이징은 프로세스의 논리 주소 공간을 "페이지" 라는 일정한 단위로 자르고,
  메모리 물리 주소 공간을 "프레임" 이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.

#### 페이지 테이블

- 프로세스가 비록 (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도 (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 "페이지 테이블"을 이용한다.

- 페이지 테이블 베이스 레지스터(PTBR)란?

  - 프로세스 마다 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재되어있다.
    CPU 내의 "페이지 테이블 베이스 레지스터"는 각 프로세스의 페이지 테이블이 적재된 주소를 가지고 있다.
  - 하지만 페이지 테이블을 메모리에 두면 문제가 있다.
    CPU가 페이지 테이블 베이스 레지스터에 접근하여 페이지 테이블을 접근하여 페이지 테이블 주소를 알아낸다
    메모리에 있는 페이지 테이블에 접근 후 프레임 주소를 알아낸다.
    프레임에 접근한다.
    (메모리 접근 시간이 매우 많아진다.)

- 페이지 테이블의 캐시 메모리(TLB)
  - 위의 PTBR은 메모리 접근 시간이 매우 많아지기 떄문에 CPU곁에 TLB라는 페이지 테이블의 캐시 메모리를 만든다.
  - CPU가 발생한 논리 주소에 대한 페이지가 TLB에 있을때 "TLB 히트", 없을 때 "TLB 미스"

#### 페이징에서의 주소 변환

- 페이징 시스템에서는 모든 논리주소가 기본적으로 (<페이지번호, 변위>)로 이루어져 있다.
  이 변위를 통해 물리주소의 프레임에 몇번지에 떨어져있는지 알 수 있다.

#### 페이지 테이블 엔트리

- 페이지 테이블의 각각의 행(<페이지 번호, 프레임 번호>)들을 페이지 테이블 엔트리 라고 한다.
  하지만 이 페이지 테이블 엔트리에는 페이지 번호와 프레임 번호 이외의 다른 중요한 정보도 있다.

- 유효비트

  - 현재 해당 페이지에 접근 가능한지 여부를 알려준다.
    유효비트가 1일 경우, 페이지가 메모리에 적재되어있고 유효비트가 0일 경우, 보조기억장치에 적재되어있는 것이다.
  - 만약 CPU가 유효비트 0인 페이지에 접근하려고하면 "페이지 폴트" 라는 예외 현상이 일어난다.
    - 페이지 폴트 시 일어나는 과정
      1. CPU는 기존의 작업 내역을 백업한다.
      2. 페이지 폴트 처리 루틴을 실행한다.
      3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효비트를 1로 변경한다.
      4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근 할 수 있게 된다.

- 보호 비트

  - 해당 페이지가 읽고 쓰기가 가능한지, 읽기만 가능한지 나타 낸다.
    1일 경우 읽고/쓰기 가 가능하고, 0일경우 읽기만 가능하다.
  - 보호 비트는 세개의 비트로 더 복잡하게 구현할 수 도 있다.
    리눅스와 비슷하게 rwx 로 나눌 수 있음.

- 참조 비트

  - CPU가 이 페이지에 접근한 적이 있는지 여부를 나타낸다.

- 수정 비트
  - 해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려준다.
  - 페이지를 수정한 직후는 보조기억장치에있는 페이지의 값과 다르다.
    따라서, 이 수정 비트를 통해 값이 쓰여진 적이있는지 판단하고 그에 따라 보조기억장치에 있는 값도 동기화해준다.
