### 명령어 병렬처리 기법

- 빠른 CPU를 만드려면 높은 클럭속도에 멀티코어, 멀티스레드를 지원하는 CPU를 만드는 것도 중요하지만,
  CPU가 놀지 않고 시간을 알뜰하게 쓰게 만드는것도 중요하다.

- 명령어 파이프라인

  - 명령어 처리과정
    1. 명령어 인출(Instruction Fetch)
    2. 명령어 해석(Instruction Decode)
    3. 명령어 실행(Execute Instruction)
    4. 결과 저장(Write Back)
  - 이러한 명령어 처리를 같은 단계의 처리과정이 겹치지 않는다면 CPU는 각 단계를 동시에 실행시킬 수 있다.

- 파이프라인 위험

  - 파이프라이닝이 높은 성능을 가져오지만, 특정 상황에서는 성능향상에 실패한다. 이러한 상황을 "파이프라인 위험" 이라고 부른다.

  - 데이터 위험

    - 명령어간의 데이터 의존성에 의해 발생한다.
    - 명령어1 : R1 = R2 + R3
      명령어2 : R4 = R1 + R5
      여기서 R1은 명령어1이 실행되야만 있을수있음. 따라서 명령어2는 명령어1과 동시에 처리되지 못한다.

  - 제어 위험

    - 분기등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생한다.
    - 프로그램 카운터가 10번지였는데 갑자기 60번지로 이동하면 11번지와 12번지의 명령어는 아무 쓸모가 없어진다.
      이것을 위한 기술중 하나가 "분기 예측" 이라고한다.

  - 구조적 위험(자원위험)

    - 명령어들을 겸쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU부품을 사용하려할 때 발생한다.
    - "자원위험" 이라고도 부름.

- 슈퍼스칼라

  - CPU내부에 여러개의 명령어 파이프라인을 포함한 구조를 슈퍼스칼라 라고한다. (공장 생산 라인을 여러개 두는 것과 같음)
  - 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 슈퍼스칼라 프로세서 or 슈퍼스칼라 CPU라고 한다.
  - 슈퍼스칼라 프로세서는 매 클럭 주기마다 동시에 여러 명령어를 인출할 수도, 실행할 수도 있어야한다.

- 비순차적 명령어 처리 (OoOE)

  - 이름 그대로 명령어를 순차적으로 실행하지 않는 기법이다.
  - 예시)
    M(100) = 1
    M(101) = 2
    M(102) = M(100) + M(101)
    M(150) = 1
    M(151) = 2
    M(152) = 3
    위 예시에서 M(102)는 M(100)과 M(101)이 실행완료 되기 까지 기다렸다가 인출할 수 있음.
    M(102)가 인출되기까지 기다려야되기 때문에 뒤에있는 M(150)~M(152)도 마찬가지로 기다리는 병목현상이 일어난다.

    ***

    M(100) = 1
    M(101) = 2
    M(150) = 1
    M(151) = 2
    M(152) = 3
    M(102) = M(100) + M(101)
    그러므로 병목현상이 일어나는 M(102)번 작업을 맨 밑으로 옮겨 작업을하면 더 효율적으로 작업할 수 있음.
    이것이 비순차적 명령어 기법이다.
